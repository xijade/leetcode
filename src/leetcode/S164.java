package leetcode;

import java.util.Arrays;

//使用桶排序，核心是，对于n个元素，设置n+1个桶,数组中的最大值最小值分别为max，min。
//令每个桶的每个区间大小是M = (max-min)/n。
//因为n+1个桶放 n个数，一定中间有个空的桶，所以最大差距最小也是M+1。(有空桶的地方不一定最大，相隔桶的最大差距2M-1)
//用的是思想，桶可以抽象，不需要创建桶。因为该问题不关注每个桶里的顺序。我只想要每个桶的两个最值
public class S164 {
    public int maximumGap(int[] nums) {
         int max,min,index;
         int N = nums.length;
         if(N < 2)
        	 return 0;
         max = min = nums[0];
         for(int i = 1;i < N;i++) {
        	 if(nums[i] > max)
        		 max = nums[i];
        	 if(nums[i] < min)
        		 min = nums[i];
         }
         int M = max - min;
         if(M == 0)
        	 return 0;
         int tem;
         int gap = (int)Math.ceil((float)M/N);
         System.out.println(N);
         System.out.println(M);
         System.out.println(gap);
         int[] bucket_max = new int[N+1];
         int[] bucket_min = new int[N+1];
         int[] bucket_exist = new int[N+1];
         Arrays.fill(bucket_exist, 0);
         
         for(int i = 0;i < N;i++) {
        	 tem = nums[i];
        	 
        	 index = (tem - min) /gap ;//
        	 
        	 if(bucket_exist[index] == 0) {
        		 bucket_min[index] = tem;
        		 bucket_max[index] = tem;
        		 bucket_exist[index] = 1;
        	 }else {
        		 bucket_min[index] = Math.min(bucket_min[index], tem);
        		 bucket_max[index] = Math.max(bucket_max[index], tem);
        	 }
         }
         
         int max_gap = bucket_max[0] - bucket_min[0];
         int pre_max = bucket_max[0];
         for(int i = 1;i <=N;i++) {
        	 if(bucket_exist[i] == 1) {
        		 
        		 max_gap = Math.max(max_gap, bucket_min[i] - pre_max);
        		 pre_max = bucket_max[i];
        	 }
         }
         
         return max_gap;
         
    }
    
    public static void main(String args[]) {
    	//int[] nums = new int[] 9,47255754,152260962,409663140,102847688,45756553,377936600,269498,375738702,263761134,53797945,329493948,224442208,508336845,189507850,40944620,127879560,119629476,186894520,62409156,693721503,4289916,523899936,28955240,266488028,20356650,40769391,483694272,97988044,84102,67246047,310688630,41288643,58965588,42881432,152159462,94786355,174917835,119224652,525034376,261516,274800528,62643819,23613832,8397240,797832131,855155367,337066320,26341480,61932200,20661075,515542796,390337500,522552030,43538516,150800550,116747540,152989123,488640056,700610304,233604,344277340,21439176,9397864,16365822,73027584,453041413,197374275,157735188,15273822,187081152,379611084,865005504,223099767,80478651,377729400,186738219,34738263,16634072,112791343,99631856,119364960,477106486,583953920,624509809,188442472,294181256,213023715,146645884,149530380,497592753,132170327,72770643,126683010,405141255,590214306,26670714,95582385,162080790,231120099,8946432,204967980,592849110,54120698,375915096,602145859,5346440,226337825,425156369,653591624,578483360,572410800,32290700,381384563,149939976,183225375,155695620,38307636,457513760,97085778,75200576,8068176,221650296,556889418,252495726,895020231,19932465,156334887,191383314,348432526,368701264,14315598,148936587,279419435,237325542,252587218,322929504,26331343,355297676,600420786,652017765,51673622,159015675};
    	S164 s = new S164();
    	int[] nums = new int[] {1,3,100};
    	
    	
    	System.out.print(s.maximumGap(nums));
    	
    }

}
